# 02 이더리움 동작방식의 이해

## Index  
- <a href="#이더리움계정">이더리움 사용자 계정</a>
- 스마트 컨트랙트 및 동작 방식
- 이더리움 가상 머신(virtual machine)
- 작업 증명 프로토콜에서의 채굴 동작 방식  
- geth 명령어 사용 방법
- 이더리움 지갑(wallet) 및 미스트(mist) 설정
- 위스퍼(Wisper)와 스웜(Swarm)  
- 이더리움의 미래  

## 이더리움의 개요  
; 이더리움은 DApp을 배포할 수 있는 탈중앙화 플랫폼  
=> DApp는 하나 이상의 스마트 컨트랙트를 사용해 생성  
=> 스마트 컨트랙트는 어떠한 다움타임, 검열, 사기 행위, 제3자 간섭 없이  
프로그래밍된 대로 정확히 실행되는 프로그램  


<div id="이더리움계정"></div>  

## 이더리움 계정  
; 비대칭 키 쌍만 있으면 됨  
(비대칭 암호 키를 생성하기 위해서는 RSA, ECC 등의 다양한 알고리즘이 있음)    
=> 이더리움은 타원 곡선 암호(ECC, elliptic curve cryptography)를 사용  
=> ECC는 다양한 매개 변수를 가지고 있으며, 속도 및 보안성을 조절하는데 사용  
=> 이더리움은 secp256k1 매개변수를 사용

1. 공개 키의 keccak-256 해시를 생성(256비트의 숫자)  
2. 앞 96비트(12바이트)를 버리고, 160비트(20바이트)의 바이너리  
데이터를 가지고 사용
3. 주소를 16진수 문자열로 인코딩. 최종적으로 40개의 문자의 바이트 스트링을  
가질 것 이며 이것이 계정 주소  

## 트랜잭션  
; 이더를 하나의 계정에서 다른 계정 또는 컨트랙트(contract)로 보내거나, 컨트랙트  
의 함수를 호출하거나, 새로운 컨트랙트를 배포하기 위한 서명된 데이터 패키지  
(트랜잭션은 ECC를 기반으로 한 디지털 서명 알고리즘ECDSA(Elliptic Curve Digital Signatrue  
Algorithm)를 이용해 서명 됨)  
- 메신지 수신자, 송신자를 식별
- 의도(intention)를 증명하기 위한 서명  
(컨트랙트의 함수를 호출하는 것이라면 입력 데이터를 포함할 수도 있고,
컨트랙트를 배포할 의도라면 초기화 코드를 포함)
- 전송할 이더의 양
- 트랜잭션 실행을 위해 허용되는 최대 연산 단계  
(가스 한도)
- 트랜잭션 송신자가 각 연산 단계를 위해 지불할 의사가 있는 비용  
(가스 가격)
- 트랜잭션 수수료(사용된 가스의 양 x 가스 가격)  


## 합의  
이더리움 네트워크 내 모든 노드는 블록체인의 사본을 가지고 있음  
- 노드가 블록체인을 임의 조작할 수 없어야 하고
- 블록이 유효한지 확인할 수 있는 메커니즘이 필요
- 두 개의 유효한 블록체인이 생성됐을 때 하나를 선택하는 방법도 필요  

=> 이더리움은 작업 증명 프로토콜을 이용해 블록체인의 변조를 방지  
(상당한 양의 계산 능력을 필요하게 함으로써 새로운 블록을 생성하는 것을 어렵게 만듬)  
=> 작업 증명 시스템 내에서 새로운 블록을 생성하는 절차를 채굴(mining)//채굴자(miner)    
=> 블록체인의 블록 수, 총 이더의 양도 제한X  


> 채굴자가 풀어야하는 퍼즐?   

=> 새롭게 브로드캐스팅된 트랜잭션 중 아직 채굴되지 않은 트랜잭션 목록을  
수집하고 유효하지 않은 트랜잭션을 필터링(개인 키로 적절히 서명 + 충분한 잔액)  
=> 채굴자는 헤더와 콘텐츠를 포함한 블록을 생성  
컨텐츠 : 블록이 포함하고 있는 트랜잭션의 목록  
헤더 : 이전 블록의 해시, 블록 번호, 논스, 목표, 타임스탬프, 난이도, 채굴자의 주소 등  
=> 퍼즐이라는 것은 블록을 해시화 했을 때 해시 값이 목표 값(target, 256비트 숫자)보다  
같거나 작아질 수 있는 논스(nonce)를 찾는 것  
=> 논스를 찾는 유일한 방법은 모든 가능성을 열거해서 대입  
=> 이더리움은 ethash라는 해싱 알고리즘 사용  
현재블록의 난이도 = 이전 블록의 난이도 + 이전블록의 난이도//2048*  
max(1-(현재 블록 타임스탬프 - 이전 블록 타임스탬프)//10, -99)  
+int(2**((현재 블록번호//100000)-1))  
=> 만약 어떤 노드가 블록 내 트랜잭션을 임의로 변경했다면, 모든 후속 블록의 논스를  
계산해야 함. 그동안 네트워크에서는 더 많은 블록이 채굴됐을 것이므로 결합된 난이도의 합이  
낮아서 해당 블록체인을 거부할 것  

## 타임스탬프  

## 논스  































---  


<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
